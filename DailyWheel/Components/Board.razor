<div class="board">

    @foreach (var pos in EnumerateSpaces(0, 0))
    {
        var space = pos.Space;
        <div>
            @if(EditMode && !space.NeverUsed){
                <span>
                    <input type="checkbox" @onchange="@(e => GivenCheckChange(e, pos.Row, pos.Col))"/>
                </span>
            }

            <input @ref="spaceRefs[pos.Row, pos.Col]"
                   class="@(SpaceInputCssClasses(space))"
                   @onkeyup="@(e => SpaceInputKeyup(e, pos.Row, pos.Col))"
                   disabled="@space.NeverUsed"
                   readonly="@(!IsEditable(space))"
                   value="@(space.IsGiven || EditMode ? space.Letter : "")"
                   maxlength="1" />
        </div>
    }
</div>

@code {
    [Parameter]
    public bool EditMode { get; set; }

    [Parameter]
    public BoardSpace[,] BoardState { get; set; } = BoardSpace.CreateEmptyBoard();

    ElementReference[,] spaceRefs { get; set; } = new ElementReference[BoardDimensions.Rows, BoardDimensions.Columns];

    char?[,] guesses { get; set; } = new char?[BoardDimensions.Rows, BoardDimensions.Columns];

    string SpaceInputCssClasses(BoardSpace boardSpace)
    {
        var classes = new List<string>() { "space-input" };
        if (!boardSpace.InPlay)
            classes.Add("unused-space");
        if (EditMode && !boardSpace.IsGiven && boardSpace.InPlay)
            classes.Add("hidden-space");
        return String.Join(" ", classes);
    }

    void GivenCheckChange(ChangeEventArgs e, int row, int col)
    {
        BoardState[row, col].IsGiven = (bool?)e.Value ?? false;
    }

    async Task SpaceInputKeyup(KeyboardEventArgs e, int row, int col)
    {
        if (e.Key.Length == 1)
        {
            var letterKeyed = e.Key.Single();

            if (EditMode)
                BoardState[row, col].Letter = letterKeyed;
            else
                guesses[row, col] = letterKeyed;

            var nextSpace = FindNextEditableSpace(row, col);
            if (nextSpace.HasValue)
                await nextSpace.Value.FocusAsync();
        }
        else if(e.Code == "Backspace" && EditMode)
        {
            BoardState[row, col].Letter = null;
        }
    }

    ElementReference? FindNextEditableSpace(int startRow, int startCol)
    {
        var space = EnumerateSpaces(startRow, startCol).Skip(1).FirstOrDefault(bp => IsEditable(bp.Space));
        if (space == null)
            return null;
        return spaceRefs[space.Row, space.Col];

    }

    bool IsEditable(BoardSpace boardSpace)
    {
        return !boardSpace.NeverUsed && (EditMode || (!EditMode && boardSpace.InPlay && !boardSpace.IsGiven));
    }

    IEnumerable<BoardPosition> EnumerateSpaces(int startRow, int startCol)
    {
        for (int row = startRow; row < BoardState.GetLength(0); row++)
        {
            for (int col = row == startRow ? startCol : 0; col < BoardState.GetLength(1); col++)
            {
                yield return new BoardPosition(BoardState[row, col], row, col);
            }
        }
    }

    record BoardPosition(BoardSpace Space, int Row, int Col);
}