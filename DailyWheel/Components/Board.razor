<div class="board">

    @foreach (var pos in EnumerateSpaces(0, 0))
    {
        var space = pos.Space;
        <input @ref="spaceRefs[pos.Row, pos.Col]"
               class="space-input @(space.InPlay ? "" : "unused-space")"
               @onkeyup="@(e => SpaceInputKeyup(e, pos.Row, pos.Col))"
               disabled="@space.NeverUsed"
               value="@space.Letter"
               maxlength="1" />
    }
</div>

@code {
    [Parameter]
    public BoardSpace[,] BoardState { get; set; } = BoardSpace.CreateEmptyBoard();

    ElementReference[,] spaceRefs { get; set; } = new ElementReference[BoardDimensions.Rows, BoardDimensions.Columns];

    async Task SpaceInputKeyup(KeyboardEventArgs e, int row, int col)
    {
        if (e.Key.Length == 1)
        {
            BoardState[row, col].Letter = e.Key.Single();
            var nextSpace = FindNextSpace(row, col);
            if(nextSpace.HasValue)
                await nextSpace.Value.FocusAsync();
        }
    }

    ElementReference? FindNextSpace(int startRow, int startCol)
    {
        var space = EnumerateSpaces(startRow, startCol).Skip(1).FirstOrDefault(bp => !bp.Space.NeverUsed);
        if (space == null)
            return null;
        return spaceRefs[space.Row, space.Col];
    }

    IEnumerable<BoardPosition> EnumerateSpaces(int startRow, int startCol)
    {
        for (int row = startRow; row < BoardState.GetLength(0); row++)
        {
            for (int col = row == startRow ? startCol : 0; col < BoardState.GetLength(1); col++)
            {
                yield return new BoardPosition(BoardState[row, col], row, col);
            }
        }
    }

    record BoardPosition(BoardSpace Space, int Row, int Col);
}